-- ESP

local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(255, 255, 255)
local OutlineTransparency = 0
local RainbowSpeed = 0.05 -- Speed of the rainbow effect

local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local connections = {}

local showUsernames = false
local usernameLabels = {}

-- Table for specific players with custom highlight and titles
local specificPlayers = {
    ["ARAMPOGI_007"] = {Color = Color3.fromRGB(255, 165, 0), Title = "Owner"}, -- Orange for Owner
    ["M4YH3M_ANT1V1RUS"] = {Color = Color3.fromRGB(255, 165, 0), Title = "Owner"}, -- Orange for Owner
    ["pvppogi_007"] = {Color = Color3.fromRGB(255, 165, 0), Title = "Co-owner"} -- Orange for Co-owner
}

-- Storage for highlights
local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

-- Rainbow effect function
local function RainbowEffect(Highlight)
    -- Ensure the rainbow effect smoothly stops if the Highlight is removed
    while Highlight and Highlight.Parent do
        for hue = 0, 1, 0.01 do
            if not Highlight or not Highlight.Parent then return end -- Stop if highlight is removed
            Highlight.FillColor = Color3.fromHSV(hue, 1, 1) -- Cycle through colors
            wait(RainbowSpeed)
        end
    end
end

-- Function to highlight a player
local function HighlightPlayer(plr)
    -- Create highlight for the player
    local Highlight = Instance.new("Highlight")
    Highlight.Name = plr.Name
    Highlight.DepthMode = DepthMode
    Highlight.FillTransparency = FillTransparency
    Highlight.OutlineColor = OutlineColor
    Highlight.OutlineTransparency = OutlineTransparency
    Highlight.Parent = Storage

    -- Set highlight color based on the player's name
    if specificPlayers[plr.Name] then
        Highlight.FillColor = specificPlayers[plr.Name].Color -- Specific player color
    else
        coroutine.wrap(RainbowEffect)(Highlight) -- Apply rainbow effect to non-specific players
    end

    -- Set the Adornee (target object) to the player's character
    local plrchar = plr.Character
    if plrchar then
        Highlight.Adornee = plrchar
    end

    -- Update highlight if the player's character respawns
    connections[plr] = plr.CharacterAdded:Connect(function(char)
        Highlight.Adornee = char
    end)
end

-- Function to create a username label (only for specific players)
local function CreateUsernameLabel(plr)
    if specificPlayers[plr.Name] then
        local char = plr.Character
        if not char or usernameLabels[plr] then return end

        local head = char:FindFirstChild("Head")
        if head then
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "UsernameLabel"
            billboard.Adornee = head
            billboard.Size = UDim2.new(2, 0, 1, 0)
            billboard.StudsOffset = Vector3.new(0, 2, 0)
            billboard.Parent = head

            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.TextScaled = true
            textLabel.TextColor3 = Color3.new(1, 1, 1)
            textLabel.Parent = billboard

            -- Set the title for the specific players
            textLabel.Text = specificPlayers[plr.Name].Title -- "Owner" or "Co-owner"

            usernameLabels[plr] = billboard
        end
    end
end

-- Function to toggle username visibility
local function ToggleUsernames()
    showUsernames = not showUsernames

    if showUsernames then
        for _, player in ipairs(Players:GetPlayers()) do
            CreateUsernameLabel(player)
        end
    else
        for _, label in pairs(usernameLabels) do
            if label then
                label:Destroy()
            end
        end
        usernameLabels = {}
    end
end

-- Function to clean up when a player leaves
local function CleanupPlayer(plr)
    local plrHighlight = Storage:FindFirstChild(plr.Name)
    if plrHighlight then
        plrHighlight:Destroy()
    end
    if connections[plr] then
        connections[plr]:Disconnect()
        connections[plr] = nil
    end

    if usernameLabels[plr] then
        usernameLabels[plr]:Destroy()
        usernameLabels[plr] = nil
    end
end

-- Apply highlights to players as they join
Players.PlayerAdded:Connect(HighlightPlayer)

-- Clean up when a player leaves
Players.PlayerRemoving:Connect(CleanupPlayer)

-- Apply highlights to all current players
for _, player in ipairs(Players:GetPlayers()) do
    HighlightPlayer(player)
end
            

-- Create a ScreenGui to hold our crosshair
local gui = Instance.new("ScreenGui")
gui.Parent = game.Players.LocalPlayer.PlayerGui

-- Create a Frame for the horizontal line of the crosshair
local horizontalLine = Instance.new("Frame")
horizontalLine.Size = UDim2.new(0, 20, 0, 2) -- Adjust the size and thickness here
horizontalLine.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Starting color
horizontalLine.BorderSizePixel = 0
horizontalLine.Parent = gui

-- Create a Frame for the vertical line of the crosshair
local verticalLine = Instance.new("Frame")
verticalLine.Size = UDim2.new(0, 2, 0, 20) -- Adjust the size and thickness here
verticalLine.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Starting color
verticalLine.BorderSizePixel = 0
verticalLine.Parent = gui

-- Function to update the crosshair's position
local function updateCrosshairPosition()
    local mouse = game.Players.LocalPlayer:GetMouse()
    horizontalLine.Position = UDim2.new(0, mouse.X - 10, 0, mouse.Y)
    verticalLine.Position = UDim2.new(0, mouse.X, 0, mouse.Y - 10)
end

-- Connect the update function to the mouse move event
game:GetService("RunService").RenderStepped:Connect(updateCrosshairPosition)

-- Function to update the crosshair's color
local function updateCrosshairColor()
    local hue = tick() % 5 / 5 -- Cycle through colors every 5 seconds
    horizontalLine.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
    verticalLine.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
end

-- Connect the update function to the heartbeat event
game:GetService("RunService").Heartbeat:Connect(updateCrosshairColor)

getgenv().CrosshairSettings = {
    Color = Color3.fromRGB(255,0,0),
    RainbowColor = true, 
    Opacity = 9,
    Length = 10,-- Length of each line
    Thickness = 2,-- Thickness of each line
    Offset = 4, -- Offset from the middle point
    Dot = true, -- not recommended
    FollowCursor = false, -- Crosshair follows the cursor
    HideMouseIcon = true, -- Hides the mouse icon, set to 0 to ignore
    HideGameCrosshair = true, -- Hides the current game's crosshair (if its supported)
    ToggleKey = Enum.KeyCode.RightAlt, -- Toggles crosshair visibility
} -- v1.2.1
loadstring(game:HttpGet("https://raw.githubusercontent.com/zzerexx/scripts/main/CustomCrosshair.lua", true))()

_G.HeadSize = 25
_G.Disabled = true

game:GetService('RunService').RenderStepped:connect(function()
if _G.Disabled then
for i,v in next, game:GetService('Players'):GetPlayers() do
if v.Name ~= game:GetService('Players').LocalPlayer.Name then
pcall(function()
v.Character.HumanoidRootPart.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize)
v.Character.HumanoidRootPart.Transparency = 100
v.Character.HumanoidRootPart.BrickColor = BrickColor.new("medium stone grey")
v.Character.HumanoidRootPart.Material = "Neon"
v.Character.HumanoidRootPart.CanCollide = false
end)
end
end
end
end)

-- Other (optional) 

local weaponSystem = require(game:service'ReplicatedStorage'.WeaponsSystem.Libraries.BaseWeapon)

local client = game:GetService('Players').LocalPlayer;

local oldFire = weaponSystem.fire;
local oldGetConfigValue = weaponSystem.getConfigValue
local oldUseAmmo = weaponSystem.useAmmo;
local oldGetAmmo = weaponSystem.getAmmoInWeapon

-- Control variables
_G.OVERPOWERED = true -- Set to 'true' to enable overpowering, 'false' to disable
_G.Silentaim = true -- Set to 'true' to enable Silent Aim, 'false' to disable

-- Function to get the closest player to aim at
local function getClosestPlayer()
    local final = nil
    local maxRange = math.huge;

    for i, player in next, game:GetService('Players'):GetPlayers() do
        if player == client then continue end
        if (not player.Character) then continue end

        local humanoid = player.Character:FindFirstChild('Humanoid');
        local head = player.Character:FindFirstChild('Head');

        if (not head) or (not humanoid) then continue end
        if (humanoid.Health <= 0) then continue end

        local vector, visible = workspace.CurrentCamera:WorldToViewportPoint(head.Position);
        if (not visible) then continue end

        local cursorPosition = game:GetService('UserInputService'):GetMouseLocation();
        local screenPosition = Vector2.new(vector.X, vector.Y);

        local difference = math.floor((screenPosition - cursorPosition).magnitude);
        if (difference < maxRange) then
            maxRange = difference
            final = head;
        end
    end
    return final;
end

-- Infinite Ammo
function weaponSystem.getAmmoInWeapon(self, ...)
    if _G.OVERPOWERED then
        return 9e9 -- Return infinite ammo if OVERPOWERED is true
    end
    return oldGetAmmo(self, ...) -- Use normal ammo count otherwise
end

function weaponSystem.useAmmo(self, ...)
    if _G.OVERPOWERED and self.ammoInWeaponValue then
        return 1 -- Use 1 ammo for infinite ammo if OVERPOWERED is true
    end
    return oldUseAmmo(self, ...) -- Normal ammo usage otherwise
end

-- Fast Fire, Automatic Guns, and No Recoil
function weaponSystem.getConfigValue(self, ...)
    local arguments = {...}

    if _G.OVERPOWERED then
        -- Set shot cooldown to 0.01 for fast firing
        if arguments[1] == 'ShotCooldown' then
            return 0.00001
        end

        -- Set weapon to automatic mode
        if arguments[1] == 'FireMode' then
            return 'Automatic'
        end

        -- Remove recoil
        if arguments[1] == 'RecoilMin' or arguments[1] == 'RecoilMax' then
            return 0
        end
    end

    return oldGetConfigValue(self, unpack(arguments)) -- Return normal values if OVERPOWERED is false
end

-- Silent Aim
function weaponSystem.fire(self, ...)
    local arguments = {...};

    if _G.Silentaim then
        local t = getClosestPlayer()
        if t then
            arguments[2] = (t.Position - arguments[1]).unit; -- Automatically adjust aim direction to the closest player's head
            arguments[3] = 1; -- Ensure the shot hits
        end
    end

    return oldFire(self, unpack(arguments)) -- Normal fire behavior if Silent Aim is false
end
